#!/usr/bin/ruby
# Programmer: Chris Bunch

$VERBOSE = nil # to supress excessive SSL cert warnings

require 'fileutils'
require 'soap/rpc/driver'
require 'yaml'

$:.unshift File.join(File.dirname(__FILE__), "..", "lib")
require 'app_controller_client'
require 'common_functions'
require 'vm_tools'
require 'node_layout'

USAGE = <<END_OF_USAGE
#{AS_VERSION}

Usage: appscale-terminate-instances [OPTIONS]

Examples:
  appscale-terminate-instances
  appscale-terminate-instances --ips ips.yaml
  appscale-terminate-instances --keyname appscale
  
Flags:
  --ips: The YAML file containing the IPs of the machines to use if not using a cloud infrastructure (for example, Xen).
  --keyname: The name of the SSH key to use for Eucalyptus. Two AppScale instances can be run concurrently in one cloud if they have unique names, and they can conflict if they have the same name.

END_OF_USAGE

YAML_CONTROL_MSG = "Please provide only one entry for your AppController."
ALL_FLAGS = ["help", "h", "usage", "ips", "version", "verbose"] +
  ["keyname", "infrastructure", "backup_to_tar", "backup_to_ebs"] +
  ["backup_neptune_info"]

require 'parse_args'

not_using_tools = IPS
keyname = KEYNAME
infrastructure = INFRASTRUCTURE

backup_to_tar = BACKUP_TAR_LOCATION
backup_to_ebs = BACKUP_EBS_LOCATION
   # TODO: should these be exclusive?
backup_neptune_info = BACKUP_NEPTUNE_INFO

backup = false
backup_info = {}
if backup_to_tar
  backup = true
  # TODO: validate that this location exists
  backup_info = ["tar_location" , backup_to_tar]
  puts "Backing up data via tar to #{backup_to_tar}\n\n"
end

if backup_to_ebs
  backup = true
  # TODO: validate that this mount exists or create it?
  backup_info = {"ebs_location" => backup_to_ebs}
  puts "Backing up data via EBS to #{backup_to_ebs}\n\n"
end

LOCATIONS_YAML = File.expand_path("~/.appscale/locations-#{keyname}.yaml")
RETVAL_FILE = File.expand_path("~/.appscale/retval")

shadow_ip = CommonFunctions.get_head_node_ip(keyname)
secret = CommonFunctions.get_secret_key(keyname)

if backup
  abort('EBS not yet supported') if backup_to_ebs

  shadow_controller = AppControllerClient.new(shadow_ip, secret)
  db_backup_location = shadow_controller.backup_appscale(backup_info)
  remote_file = db_backup_location.scan(/(\/.*)/).flatten.to_s

  command = "scp -i ~/.appscale/#{keyname}.key " + 
    "root@#{shadow_ip}:#{remote_file} #{backup_to_tar}"
  `#{command}`

  puts "Your database information has been backed up to #{backup_to_tar}\n"
else
  puts "Not backing up data.\n\n"
end

if BACKUP_NEPTUNE_INFO
  remote_file = "/etc/appscale/neptune_info.txt"
  command = "scp -i ~/.appscale/#{keyname}.key " +
    "root@#{shadow_ip}:#{remote_file} #{backup_neptune_info}"
  `#{command}`

  puts "Your Neptune information has been backed up to #{backup_neptune_info}\n"
end

if VALID_CLOUD_TYPES.include?(INFRASTRUCTURE)
  puts "About to terminate instances spawned via " + 
    "#{infrastructure} with keyname '#{keyname}'..."
  sleep(2)

  acc = AppControllerClient.new(shadow_ip, secret)
  acc.kill()

  puts "Terminated AppScale in cloud deployment."
else
  puts "About to terminate instances spawned via " + 
    "Xen/KVM with keyname '#{keyname}'..."
  sleep(2)

  ssh_key_location = "~/.appscale/#{keyname}"
  table = CommonFunctions.get_table(keyname)

  command = "service appscale-controller stop"
  
  boxes_shut_down = 0
  node_layout = NodeLayout.new(IPS, { :database => table }, skip_replication=true)

  unless node_layout.valid?
    puts "Invalid IPs file, unable to terminate instances:"
    puts node_layout.errors
    exit(0)
  end

  ips = node_layout.nodes.collect { |node| node.id }.compact

  threads = []
  ips.each { |ip|
    threads << Thread.new {
      CommonFunctions.run_remote_command(ip, command, ssh_key_location, @@verbose)
      sleep(5)
      CommonFunctions.run_remote_command(ip, command, ssh_key_location, @@verbose)
    }
  }

  threads.each { |t| t.join }

  ips.each { |ip|
    print "Shutting down AppScale components at #{ip}"
    STDOUT.flush
    loop {
      ps = `ssh root@#{ip} -o StrictHostkeyChecking=no -i #{ssh_key_location} 'ps x'`
      processes_left = ps.scan(/appscale-controller stop/).length
      break if processes_left == 0
      print '.'
      STDOUT.flush
      sleep(0.3)
    }
    boxes_shut_down += 1
    print "\n"
  }

  puts "Terminated AppScale across #{boxes_shut_down} boxes."
end

FileUtils.rm_f(LOCATIONS_YAML) if File.exists?(LOCATIONS_YAML)
FileUtils.rm_f(RETVAL_FILE) if File.exists?(RETVAL_FILE)

